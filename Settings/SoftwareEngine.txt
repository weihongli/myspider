第1章 软件工程学概论
	1.1 软件的基本概念
		1.1.1 软件与软件特性
		1.1.2 软件的分类
	1.2 软件危机
		1.2.1 软件危机真正的含义
		1.2.2 软件危机的具体表现
		1.2.3 软件危机产生的原因
		1.2.4 解决软件危机的途径
	1.3 软件工程
		1.3.1 软件工程的基本原理
		1.3.2 软件工程学科包含的领域
		1.3.3 软件工程方法学
	1.4 软件工程于一般工程的差异
		1.4.1 软件工程课程与其他软件专业课的区别
		1.4.2 软件工程技术的两个特点
	1.5 软件过程与软件生命周期
		1.5.1 软件过程
		1.5.2 软件生命周期的各个阶段
	1.6 常见的软件过程模型
		1.6.1 瀑布模型
		1.6.2 快速原型模型
		1.6.3 演化模型
		1.6.4 螺旋模型
		1.6.5 喷泉模型
	1.7 程序设计方法
		1.7.1 结构化程序设计方法
		1.7.2 模块化与信息隐藏
		1.7.3 面向对象程序设计
	1.8 软件开发方法
		1.8.1 传统方法学
		1.8.2 面向对象方法学
第2章 项目分析与软件需求分析
	2.1 软件项目的问题定义
	2.2 软件项目可行性分析
		2.2.1 可行性研究的任务
		2.2.2 可行性研究的过程
		2.2.3 系统流程图
		2.2.4 数据流图
		2.2.5 数据字典
		2.2.6 成本/效益分析
	2.3 软件系统的需求
		2.3.1 需求分析概述
		2.3.2 需求分析的困难
		2.3.3 功能需求
		2.3.4 领域需求
		2.3.5 非功能需求
	2.4 用户需求获取
	2.5 需求分析的方法
		2.5.1 功能解析法
		2.5.2 结构化分析法
		2.5.3 信息建模法
		2.5.4 面向对象分析法
	2.5 软件需求文档与规格说明
		2.5.1 自然语言描述
		2.5.2 结构化描述
		2.5.3 软件需求文档
	2.6 系统流程图
	2.7 数据流图
		2.7.1 数据流图的符号
		2.7.2 设计数据流图的步骤和示例
		2.7.3 数据流图中命名的可理解性
		2.7.4 数据流图的用途
		2.7.5 数据流图中的数据字典
	2.8 实体-联系图
	2.9 需求分析中使用的其他图形工具
	2.10 面向数据流的建模
	2.11 需求有效性验证
	2.12 实例分析—教材征订业务分析
第3章 软件总体设计
	3.1 总体设计
	3.2 软件总体设计原理
		3.2.1 设计原理
		3.2.2 启发式规则
	3.3 描绘软件结构的图形工具
		3.3.1 层次图和HIPO图
		3.3.2 软件结构图
	3.4 映射数据流到软件结构
		3.4.1 变换流
		3.4.2 事务流
		3.4.3 变换映射(变换分析)
		3.4.4 事务映射(事务分析)
		3.4.5 设计优化—精化软件结构
	3.5 数据库结构设计过程
	3.6 实例分析
第4章 软件详细设计
	4.1 结构化程序设计
		4.1.1 结构化的控制结构
		4.1.2 结构化程序设计的实现方法
		4.1.3 结构化程序设计的特点
	4.2 用户界面设计
		4.2.1 黄金规则
		4.2.2 用户界面的分析与设计
		4.2.3 界面分析
		4.2.4 界面设计步骤
	4.3 程序算法设计工具
		4.3.1 图形化设计工具
		4.3.2 表格式设计表示
		4.3.3 程序设计语言
		4.3.4 程序算法设计工具的比较
	4.4 面向数据结构的设计方法
		4.4.1 Jackson数据结构图
		4.4.2 改进的Jackson图
		4.4.3 Jackson方法的设计过程
	4.5 程序复杂度的概念及度量方法
第5章 软件实现
	5.1 软件编码
		5.1.1 编码目的
		5.1.2 程序设计语言的选择
		5.1.3 良好的编程实践
		5.1.4 程序员的基本素质
	5.2 软件测试基础
	5.3 测试设计和管理
		5.3.1 错误曲线
		5.3.2 软件测试配置
		5.3.3 测试用例设计
	5.4 软件测试过程
		5.4.1 软件测试基本原则
		5.4.2 软件测试的步骤、测试信息流
		5.4.3 软件测试组织与人员
	5.5 软件测试的基本方法
		5.5.1 软件测试方法与技术
		5.5.2 软件测试的误区
	5.6 软件测试策略
		5.6.1 测试策略
		5.6.2 单元测试
		5.6.3 集成测试(组装测试)
		5.6.4 确认测试(有效性测试)
		5.6.5 系统测试与验收测试
	5.7 白盒测试
		5.7.1 逻辑覆盖法
		5.7.2 基本路径测试法
	5.8 黑盒测试
		5.8.1 等价类划分法
		5.8.2 边界值分析法
		5.8.3 错误推测法
		5.8.4 状态测试法
	5.9 回归测试
	5.10 软件调试
		5.10.1 软件调试的目的与原则
		5.10.2 软件调试技术
		5.10.3 调试技巧
第6章 软件维护
	6.1 软件维护的基本概念
	6.2 软件维护的任务和分类
	6.3 软件维护过程
	6.4 维护的管理
	6.5 预防性维护
	6.6 软件维护的副作用
	6.7 软件文档与编写要求及方法
		6.7.1 软件文档的重要性与分类
		6.7.2 软件文档应该满足的要求
		6.7.3 对软件文档编制的质量要求
		6.7.4 软件文档的管理和维护
	6.8 软件逆向工程和再工程
第7章 面向对象软件工程方法学
	7.1 面向对象的概念
	7.2 从认识论看面向对象方法的形成
		7.2.1 软件开发—对事物的认识和描述
		7.2.2 语言的鸿沟
		7.2.3 面向对象编程语言的发展使鸿沟变小
		7.2.4 软件工程学的作用
	7.3 面向对象方法的基本概念
		7.3.1 面向对象的基本概念
		7.3.2 面向对象的主要特征
	7.4 统一过程与统一建模语言
		7.4.1 统一过程概述
		7.4.2 统一过程生命周期
		7.4.3 统一建模语言
	7.5 迭代和增量过程
		7.5.1 为什么采用迭代和增量的开发方法
		7.5.2 迭代方法是风险驱动的
		7.5.3 通用迭代过程
		7.5.4 一次迭代产生一个增量结果
		7.5.5 在整个生命周期上的迭代
		7.5.6 由迭代过程来演化模型
第8章 用例驱动
	8.1 用例驱动开发概述
	8.2 为什么使用用例
		8.2.1 根据需求的价值捕获用例
		8.2.2 用例驱动开发过程
	8.3 确定客户需要什么
	8.4 需求工作流
	8.5 领域模型
	8.6 业务模型
	8.7 补充需求
	8.8 初始需求
	8.9 初始需求：考勤系统实例研究
		8.9.1 聆听
		8.9.2 确定参与者
		8.9.3 确定用例
		8.9.4 简要说明用例
		8.9.5 描述用例模型
	8.10 继续需求流：考勤系统实例研究
		8.10.1 区分用例的优先级
		8.10.2 详细描述用例
		8.10.3 构造用户界面原型
	8.11 修订需求：考勤系统实例研究
	8.12 测试工作流：考勤系统实例研究
	8.13 需求规格说明书
第9章 面向对象分析
	9.1 分析工作流
	9.2 分析模型
	9.3 确定分析包
		9.3.1 处理分析包之间的共性
		9.3.2 确定服务包
		9.3.3 确定分析包间的依赖
	9.4 提取实体类
		9.4.1 实体类的提取
		9.4.2 面向对象分析：电梯问题实例研究
		9.4.3 功能建模：电梯问题实例研究
		9.4.4 实体类建模：电梯问题实例研究
		9.4.5 动态建模：电梯问题实例研究
		9.4.6 测试工作流：电梯问题案例研究